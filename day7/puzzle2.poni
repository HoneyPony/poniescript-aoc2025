var NEWLINE = "\n"[0];
var S       = "S"[0];
var CARET   = "^"[0];
var PIPE    = "|"[0];

class Node {
    var key  : vec2i = (0, 0);
    var value: int = 0;
    var next : Node? = nil;
}

class LinkedList {
    var head: Node? = nil;
    var tail: Node? = nil;

    fun push(node: Node) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next = node;
        tail = node;
    }
    
    fun lookup(key: vec2i) -> (int, bool) {
        var iter = head;
        loop {
            var item = iter else { break; };

            if item.key.0 == key.0 and item.key.1 == key.1 {
                return (item.value, true);
            }

            iter = item.next;
        }
        return (0, false);
    }
}

class Grid {
    var text  : StrBuf = "";
    var width : int = 0;
    var height: int = 0;

    var cached: LinkedList = new LinkedList{};

    fun get(xy: vec2i) -> int {
        if xy.0 < 0 or xy.0 >= width { return 0; }
        if xy.1 < 0 or xy.1 >= height { return 0; }
        return text[xy.1 * (width + 1) + xy.0];
    }

    fun set(xy: vec2i, val: int) {
        if xy.0 < 0 or xy.0 >= width { return; }
        if xy.1 < 0 or xy.1 >= height { return; }
        text[xy.1 * (width + 1) + xy.0] = val;
    }

    fun has_active_splitter(xy: vec2i) -> bool {
        if get(xy) != CARET { return false; }
        return get(xy - (0, 1)) == PIPE;
    }

    fun compute_beam_uncached(pos: vec2i) -> int {
        while pos.1 < height {
            var next = get(pos);
            if next == CARET {
                var left = pos - (1, 0);
                var right = pos + (1, 0);

                return compute_beam(left) + compute_beam(right);
            }
            pos.1 = pos.1 + 1;
        }

        // Escaped beam is 1.
        return 1;
    }

    fun compute_beam(pos: vec2i) -> int {
        var check = cached.lookup(pos);
        if check.1 {
            return check.0;
        }

        var val = compute_beam_uncached(pos);
        cached.push(new Node { key: pos, value: val });

        return val;
    }

    fun compute_from_s() -> int {
        var pos = (0, 0);
        while pos.0 < width {
            if get(pos) == S {
                print("start beam @ ", pos);
                return compute_beam(pos);
            }
            pos.0 = pos.0 + 1;
        }
        return 0;
    }
}

fun make_grid(text: StrBuf) -> Grid {
    // Compute width so we can treat text like a 2D array
    var width = 0;
    while text[width] != NEWLINE {
        width = width + 1;
    }

    var height = 0;
    while height * width < text.length {
        height = height + 1;
    }
    height = height - 2;

    new Grid {
        text: text,
        width: width,
        height: height,
    }
}

fun init() {
    var grid = make_grid(read_file("input.txt"));
    print(grid.width, grid.height);
    var value = grid.compute_from_s();
    print(value);

    // var y = 1;
    // while y < grid.height {
    //     grid.process_row(y);
    //     y = y + 1;
    // }

    // Print rows for debugging
    //print(grid.text);
    //print(grid.split_count);
}
