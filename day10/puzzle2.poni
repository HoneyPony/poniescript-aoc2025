var ZERO    = "0"[0];
var NINE    = "9"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

var LBRACKET = "["[0];
var RBRACKET = "]"[0];
var DOT = "."[0];
var HASH = "#"[0];

var LPAREN = "("[0];
var RPAREN = ")"[0];
var COMMA  = ","[0];
var LBRACE = "{"[0];
var RBRACE = "}"[0];

class Box {
    var elems: DynArray[bool] = [];
}

// return int for ==...
fun is_even(x: int) -> int {
    while x > 0 {
        x = x - 2;
    }
    // odd
    if x < 0 { 0 } else { 1 }
}

// class ExtraConstraints {
//     var elems: DynArray[(DynArray[int], float)] = [];

//     var best = 100000000000;
//     var best_assignment: DynArray[(int, float)] = [];

//     fun solve() {
//         var assignment: DynArray[(int, float)] = [];
//         for i in 0..elems.length {

//         }
//     }
// }

class Row {
    var elems: DynArray[float] = [];

    fun minus(idx: int, row: Row) {
        if elems[idx] == 0 {
            return;
        }
        var coefficient = elems[idx] / row.elems[idx];
        for i in 0..elems.length {
            elems[i] = elems[i] - coefficient * row.elems[i];
        }
    }

    fun sub(value: float) {
        for i in 0..elems.length {
            elems[i] = elems[i] - value;
        }
    }

    fun normalize(idx: int) {
        var coefficient = elems[idx];
        for i in 0..elems.length {
            elems[i] = elems[i] / coefficient;
        }
    }

    fun print_me() {
        var s = str("");
        for i in 0..elems.length {
            if i > 0 { s = str(s, ", "); }
            s = str(s, elems[i]);
        }

        print("[", s, "]");
    }
}

class Assign {
    var col: int = 0;
    var val: int = 0;
}

class Pivot {
    var val: float = 0;
    var col: int = 0;
    var row: int = 0;
}

class Matrix {
    var rows: DynArray[Row] = [];

    var best: float = 100000000;
    var got_solution: bool = false;

    var test_counts: DynArray[int] = [];
    var best_counts: DynArray[int] = [];

    fun swap(idx1: int, idx2: int) {
        var tmp = rows[idx1];
        rows[idx1] = rows[idx2];
        rows[idx2] = tmp;
    }

    fun rref() {
        var cols = rows[0].elems.length;
        var row_count = rows.length;
        var next_row = 0;
        var next_col = 0;
        while next_row < rows.length {
            var i = next_row;
            if i >= cols - 1 { break; }
            if next_col >= cols - 1 { break; }
            // We want to find a row with a non-zero entry, swap it to be
            // the ith row, and then delete it from all the other rows.
            var from_idx = (0, false);
            for j in next_row..row_count {
                if rows[j].elems[next_col] != 0 {
                    from_idx = (j, true);
                    break;
                }
            }

            // Okay, if we have this row, then swap it, and then delete it
            // from every other row.
            if from_idx.1 {
                swap(next_row, from_idx.0);

                var row = rows[next_row];
                row.normalize(next_col);
                for j in 0..row_count {
                    if j != next_row {
                        rows[j].minus(next_col, row);
                    }
                }
                next_row = next_row + 1;
            }
            next_col = next_col + 1;
        }
    }

    fun print_me() {
        for i in 0..rows.length {
            rows[i].print_me();
        }
    }

    fun good() -> bool {
        var col_count = rows[0].elems.length;
        var row_count = rows.length;
        col_count <= row_count
    }

    fun dfs(maxneg: float, puzzle: Puzzle, positives: DynArray[bool], pivots: DynArray[Pivot], assign: DynArray[Assign], test_arr: DynArray[float], idx: int) {
        var row_count = rows.length;
        var col_count = rows[0].elems.length;

        //print(assign[0], " ", assign[1], " ", idx >= assign.length);
        
        if idx >= assign.length {
            // var as = str("");
            // for j in 0..assign.length {
            //     as = str(as, ", ", assign[j]);
            // }

            // var ta = str("");
            // for j in 0..test_arr.length {
            //     ta = str(ta, ", ", test_arr[j]);
            // }
            // print("assign: ", as, " test_arr: ", ta);

            // Test if this is a solution.
            var is_good = true;
            for i in 0..test_arr.length {
                var k = roundit(test_arr[i]);
                var dif = k - test_arr[i];
                if ((dif < -0.03) or dif > 0.03) {
                    //print("reject: non-int @ ", i);
                    is_good = false; break; }

                if k != puzzle.joltages[i] {
                    //print("reject: wrong joltage @ ", i, " ", k " vs ", puzzle.joltages[i]);
                    is_good = false; break; }
            }

            var sum = 0.0;
            for i in 0..puzzle.buttons.length {
                var count = 0.0; //rows[i].elems[col_count - 1];
                for j in 0..pivots.length {
                    if i == pivots[j].col {
                        count = count + pivots[j].val;
                        var pr = pivots[j].row;
                        for a in 0..assign.length {
                            count = count - rows[pr].elems[assign[a].col] * assign[a].val; 
                        }
                    }
                }
                for j in 0..assign.length {
                    if i == assign[j].col {
                        count = assign[j].val;
                    }
                }
                // var count = if i < row_count {
                //     // 1x 0y 0z 0d 2e 3f | 23
                //     // -> x = 23 - 2e - 3f
                //     var c = rows[i].elems[col_count - 1];
                //     for j in row_count..col_count - 1 {
                //         c = c - rows[i].elems[j] * assign[j - row_count];
                //     }
                //     c
                // }
                // else {
                //     // Read this counter from the assignment we're trying.
                //     assign[i - row_count]
                // };

                //print("count @ ", i, " = ", count);

                sum = sum + count;

                var k = roundit(count);
                var dif = k - count;
                if ((dif < -0.03) or dif > 0.03) { is_good = false; break; }

                test_counts[i] = k;

                if k < 0 { is_good = false; break; }
                0;
            }

            if is_good {
                //print("is good: sum = ", sum);
                if sum < best {
                    best = sum;
                    got_solution = true;
                    print("new best: ", best);

                    for i in 0..puzzle.buttons.length {
                        best_counts[i] = test_counts[i];
                    }
                }
            }
            return;
        }

        var original = assign[idx].val;
        

        var reset: DynArray[float] = [];
        for i in 0..test_arr.length { reset.push(0); }

        for i in 0..test_arr.length {
            reset[i] = test_arr[i];
        }

        loop {
            var done = false;

            for j in 0..puzzle.joltages.length {
                test_arr[j] = 0;
            }

            var large = false;

            for i in 0..puzzle.buttons.length {
                // var count = if i < row_count {
                //     // 1x 0y 0z 0d 2e 3f | 23
                //     // -> x = 23 - 2e - 3f
                //     var c = rows[i].elems[col_count - 1];
                //     for j in row_count..col_count - 1 {
                //         c = c - rows[i].elems[j] * assign[j - row_count];
                //     }
                //     if c < 0 and positives[i] {
                        
                //         //print("bad c @ ", i, " = ", c);
                //         for j in row_count..col_count - 1{
                //             //print("assign @ ", j, " ", assign[j - row_count]);
                //         }
                //         done = true;
                //     }
                //     c
                // }
                // else {
                //     // Read this counter from the assignment we're trying.
                //     assign[i - row_count]
                // };
                var count = 0.0; //rows[i].elems[col_count - 1];
                for j in 0..pivots.length {
                    if i == pivots[j].col {
                        count = count + pivots[j].val;
                        var pr = pivots[j].row;
                        for a in 0..assign.length {
                            count = count - rows[pr].elems[assign[a].col] * assign[a].val; 
                            //print("count: @ ", count);
                        }
                    }
                }
                for j in 0..assign.length {
                    if i == assign[j].col {
                        count = assign[j].val;
                    }
                }
                

                if count > 10000 {
                    large = true;
                }

                for j in 0..puzzle.joltages.length {
                    test_arr[j] = test_arr[j] + count * if puzzle.buttons[i].elems[j] { 1 } else { 0 };
                }
            }

            
            for j in 0..puzzle.joltages.length {
                // Overshot. Whoops.
                if large { print(test_arr[j], " ", puzzle.joltages[j]); }
                if test_arr[j] + maxneg > puzzle.joltages[j] + 1 {
                    print(j, " ", test_arr[j] + maxneg, " > ", puzzle.joltages[j] + 1);
                    done = true;
                    break;
                }
            }

            dfs(maxneg, puzzle, positives, pivots, assign, test_arr, idx + 1);

            // ?
            if done or assign[idx].val > 400 {
                break;
            }

            assign[idx].val = assign[idx].val + 1;
        }

        for j in 0..puzzle.joltages.length {
            test_arr[j] = reset[j];
        }

        assign[idx].val = original;
    }

    fun get_best(puzzle: Puzzle) -> float {
        for i in 0..puzzle.buttons.length {
            best_counts.push(0);
            test_counts.push(0);
        }

        var col_count = rows[0].elems.length;
        var row_count = rows.length;
        if (col_count - 1) < row_count {
            print_me();
            // Best is simply the sum of the right column.
            print(col_count, " ", row_count, " ", best_counts.length);
            var sum = 0.0;
            for i in 0..col_count - 1 {
                sum = sum + rows[i].elems[col_count - 1];
                best_counts[i] = roundit(rows[i].elems[col_count - 1]);

                var at = rows[i].elems[col_count - 1];
                if at < 0 {
                    print("uh oh: ", i, " => ", at);
                }
            }
            got_solution = true;
            return sum;
        }

        // TODO:

        // var num_negative_rows = 0;
        // for i in 0..row_count {
        //     if rows[i].elems[col_count - 1] < 0 {
        //         num_negative_rows = num_negative_rows + 1;
        //     }
        // }
        // print("num negative: ", num_negative_rows);

        print("bad matrix. creating sub-matrix and iterating...");
        print_me();
        var assignments: DynArray[Assign] = [];
        var pivots: DynArray[Pivot] = [];
        var positives: DynArray[bool] = [];
        var maxneg: float = 0.0;
        for i in 0..row_count {
            positives.push(rows[i].elems[col_count - 1] >= 0);
            if rows[i].elems[col_count - 1] < 0 {
                maxneg = maxneg + rows[i].elems[col_count - 1];
            }
            //print("positives @ ", i " ", positives[i]);
        }

        var na_col = 0;
        var na_row = 0;
        while na_row < row_count and na_col < col_count - 1 {
            if rows[na_row].elems[na_col] == 1 {
                print("new pivot: ", na_row, " ", na_col);
                pivots.push(new Pivot { row: na_row, col: na_col, val: rows[na_row].elems[col_count - 1] });
                na_row = na_row + 1;
                na_col = na_col + 1;
            }
            else {
                while na_row < row_count and na_col < col_count - 1 and rows[na_row].elems[na_col] != 1 {
                    print("assignment column: (a) ", na_col);
                    assignments.push(new Assign { col: na_col, val: 0 });
                    na_col = na_col + 1;
                }
                print("new pivot: ", na_row, " ", na_col);
                pivots.push(new Pivot { row: na_row, col: na_col, val: rows[na_row].elems[col_count - 1] });
                na_col = na_col + 1;
                na_row = na_row + 1;
            }
        }

        // Now, push assignments until we run out of columns.
        while na_col < col_count - 1 {
            print("assignment column: (b) ", na_col);
            assignments.push(new Assign { col: na_col, val: 0 });
            na_col = na_col + 1;
        }

        // for i in row_count..col_count - 1 {
        //     assignment.push(0);

        //     // Check each row. If we have any rows of the form
        //     // 0 + -A<this> + 0 + 0 .. = -K
        //     //
        //     // then the assignment must at minimum be K / A, to make
        //     // the other value positive.
        //     // for j in 0..row_count {
        //     //     var K = rows[j].elems[col_count - 1];
        //     //     var A = rows[j].elems[i];
        //     //     if K < 0 and A < 0 {

        //     //         var no_others = true;
        //     //         for k in row_count..col_count - 1 {
        //     //             if k != i {
        //     //                 if rows[j].elems[k] < 0 { no_others = false; break; }
        //     //             }
        //     //         }

        //     //         if no_others {
        //     //             var min =  roundit(K / A);
        //     //             if min > assignment[i - row_count] {
        //     //                 assignment[i - row_count] = min;
        //     //             }
        //     //             print("assign ", i, " = ", assignment[i - row_count]);
        //     //         }
        //     //     }
        //     // }
        // }

        var test_arr: DynArray[float] = [];
        
        for i in 0..puzzle.joltages.length { test_arr.push(0); }

        //print("assignment.len: ", assignment.length);
        dfs(maxneg, puzzle, positives, pivots, assignments, test_arr, 0);

        return best;
    }
}

class Combos {
    var from: Matrix = new Matrix{};
    var to: Matrix = new Matrix{};

    var best: float = 1000000000.0;

    fun initialize() {
        for i in 0..from.rows.length {
            var row = new Row{};
            // Make a square matrix, plus one column.
            for i in 0..from.rows.length + 1 {
                row.elems.push(0);
            }
            to.rows.push(row);
        }

        print("to dims: ", to.rows.length, " ", to.rows[0].elems.length);
    }

    fun dbg(skip_cols: DynArray[int]) {
        var s = str("");
        for i in 0..skip_cols.length {
            s = str(s, ", ", skip_cols[i]);
        }
        print("doing combo: [", s, "]");
    }

    fun comb(skip_cols: DynArray[int], nest: int, prev: int) {
        var cols = from.rows[0].elems.length;

        fun should_not_skip(skip_cols: DynArray[int], c: int) -> bool {
            for i in 0..skip_cols.length {
                if skip_cols[i] == c { return false; }
            }
            true
        }

        if nest >= skip_cols.length {
            // Actually do the combination.
            dbg(skip_cols);

            for row in 0..from.rows.length {
                var col_write = 0;
                for col in 0..cols {
                    if should_not_skip(skip_cols, col) {
                        //print("row, col_write: ", row, " ", col_write);
                        to.rows[row].elems[col_write] = from.rows[row].elems[col];
                        col_write = col_write + 1;
                    }
                }
            }

            to.rref();
            to.print_me();
            var best_ = 0; //to.get_best(puzzle);

            print(" -> ", best_);

            if best_ < 0 {
                print("uh oh");
            }

            if best_ < best {
                best = best_;
            }

            return;
        }

        for i in prev..cols - 1 {
            skip_cols[nest] = i;
            comb(skip_cols, nest + 1, i + 1);
        }
    }

    fun solve() {
        var skip_cols: DynArray[int] = [];
        for i in 0..(from.rows[0].elems.length - to.rows[0].elems.length) {
            skip_cols.push(0);
        }

        comb(skip_cols, 0, 0);
    }
}

class Solution {
    var elems: DynArray[bool] = [];

    var best: int = 10000000000;
    var has_solution: bool = false;

    fun is_le(attempt: DynArray[int], real: DynArray[int]) -> bool {
        for i in 0..attempt.length {
            if attempt[i] > real[i] { return false; }
        }
        return true;
    }

    fun is_solution(attempt: DynArray[int], real: DynArray[int]) -> bool {
        for i in 0..attempt.length {
            if attempt[i] != real[i] { return false; }
        }
        return true;
    }

    fun incr(attempt: DynArray[int], button: Box, by: int) {
        for i in 0..attempt.length {
            if button.elems[i] {
                attempt[i] = attempt[i] + by;
            }
        }
    }

    fun decr(attempt: DynArray[int], button: Box, by: int) {
        for i in 0..attempt.length {
            if button.elems[i] {
                attempt[i] = attempt[i] - by;
            }
        }
    }

    // At the given index of button, try increasing all the values
    // in our attempted solution, until we overshoot.
    //
    // If the solution ended up correct, yippee.
    fun dfs(attempt: DynArray[int], puzzle: Puzzle, idx: int, num_pressed: int) {
        if idx >= puzzle.buttons.length {
            return;
        }
        var button = puzzle.buttons[idx];

        var my_presses = 0;

        while (my_presses + num_pressed < best) and is_le(attempt, puzzle.joltages) {
            incr(attempt, button, 1);
            //print("[", idx, " - ", num_pressed, "] attempt: ", attempt[0], " ", attempt[1], " ", attempt[2], " ", attempt[3], " ", attempt[4], " ", attempt[5]);
            my_presses = my_presses + 1;
        }
        decr(attempt, button, 1);
        my_presses = my_presses - 1;

        //print("[", idx, "] starting presses: ", my_presses);

        // Now, while we still have any presses left, check for solutions.
        while my_presses > 0 {
            if is_solution(attempt, puzzle.joltages) {
                if my_presses + num_pressed < best {
                    best = my_presses + num_pressed;
                    has_solution = true;
                }
            }
            dfs(attempt, puzzle, idx + 1, num_pressed + my_presses);

            // Then, decrement.
            my_presses = my_presses - 1;
            decr(attempt, button, 1);
        }
    }

    fun solve_for(puzzle: Puzzle) {
        // Initialize our attempt array.
        //
        // We need exactly one button in it for each button in our solution.
        var attempt: DynArray[int] = [];
        for i in 0..puzzle.joltages.length {
            attempt.push(0);
        }

        var num_pressed = 0;
        for i in 0..puzzle.buttons.length {
            if elems[i] {
                //print("press ", i);
                incr(attempt, puzzle.buttons[i], 1);
                //print(" -> ", attempt[0], " ", attempt[1], " ", attempt[2], " ", attempt[3], " ", attempt[4], " ", attempt[5]);
                num_pressed = num_pressed + 1;
            }
        }

        //print("attempt: ", attempt[0], " ", attempt[1], "...");

        // OPT: Check parity right now. If it doesn't match, give up.
        // for i in 0..attempt.length {
        //     if is_even(attempt[i]) != is_even(puzzle.joltages[i]) {
        //         print("joltage parity mismatch @ ", i);
        //         return;
        //     }
        // }

        dfs(attempt, puzzle, 0, num_pressed);
    }
}

class Puzzle {
    var box: Box = new Box{};
    var buttons: DynArray[Box] = [];
    var joltages: DynArray[int] = [];

    // The best value starts at the number of elements, and then improves
    // as we search more things.
    //var part1_best: int = box.elems.length;
    //var part1_best_dbg: DynArray[bool] = [];

    var solutions: DynArray[Solution] = [];
}

class Text {
    var text: StrBuf = "";
    var idx : int    = 0;

    fun box() -> Box? {
        while idx < text.length and text[idx] != LBRACKET {
            idx = idx + 1;
        }
        if idx >= text.length {
            return nil;
        }

        // Skip the [
        idx = idx + 1;
        var box = new Box{};
        while text[idx] != RBRACKET {
            box.elems.push(text[idx] == HASH);
            idx = idx + 1;
        }

        // Skip the ]
        idx = idx + 1;

        box
    }

    fun button(other: Box) -> Box? {
        while text[idx] != LPAREN and text[idx] != LBRACE {
            idx = idx + 1;
        } 

        // No more buttons.
        if text[idx] == LBRACE { return nil; }

        var box = new Box{};
        for i in 0..other.elems.length {
            box.elems.push(false);
        }

        idx = idx + 1; // Get rid of LPAREN
        while text[idx] != RPAREN {
            var number = 0;
            while is_digit(text[idx]) {
                number = (number * 10 + text[idx] - ZERO);
                idx = idx + 1;
            }

            // Set the value in the button
            box.elems[number] = true;

            if text[idx] != RPAREN {
                idx = idx + 1; // Skip comma
            }
        }

        idx = idx + 1; // Skip rparen

        box
    }

    fun joltages() -> DynArray[int] {
        while text[idx] != LBRACE {
            idx = idx + 1;
        }

        var joltages: DynArray[int] = [];

        idx = idx + 1;
        while text[idx] != RBRACE {
            var number = 0;
            while is_digit(text[idx]) {
                number = (number * 10 + text[idx] - ZERO);
                idx = idx + 1;
            }

            joltages.push(number);

            if text[idx] != RBRACE {
                idx = idx + 1;
            }
        }

        joltages
    }
}

fun get_text() -> Text { new Text { text: read_file("input.txt") } }

fun init() {
    var text = get_text();
    var puzzles: DynArray[Puzzle] = [];
    loop {
        var box = text.box();
        var box = box else { break; };

        var puzzle = new Puzzle { box: box };
        loop {
            var button = text.button(box);
            puzzle.buttons.push(button else { break; });
        }

        var joltages = text.joltages();
        puzzle.joltages = joltages;

        puzzles.push(puzzle);
    }

    // Ones to manually check: idx 5, idx 176, idx 51, idx 175, 13, 15, 16
    var sum = 0;
    var sum2 = 0;
    for k in 0..puzzles.length {
        var puzzle = puzzles[k];
        var matrix = new Matrix{};
        for i in 0..puzzle.joltages.length {
            var row = new Row{};
            for j in 0..puzzle.buttons.length {
                row.elems.push(if puzzle.buttons[j].elems[i] { 1 } else { 0 });
            }
            row.elems.push(puzzle.joltages[i]);
            matrix.rows.push(row);
        }

        matrix.rref();
        print("solve for: ", k);
        var solution = matrix.get_best(puzzle);
        print("solution: ", matrix.got_solution, " ", k, " -> ", solution);

        var solstr = str("");
        var comma = false;
        for i in 0..matrix.best_counts.length {
            if comma {
                solstr = str(solstr, ", ", matrix.best_counts[i]);
            }
            else {
                solstr = str(solstr, matrix.best_counts[i]);
            }
            comma = true;
            
            sum2 = sum2 + matrix.best_counts[i];
        }
        print("solution= ", solstr);

        sum = sum + roundit(solution);
        //if k > 5 { break; }

        //break;
        // if solution < 0 {
        //     break;
        // }

        // if matrix.good() {
        //    // print("--- ", k, " ---");
        //    // matrix.print_me();
        //     matrix.rref();
        //     //print(">-- ", k, " rref ---");
        //     //matrix.print_me();
        //     print("[good] solution: ", matrix.get_best());
        // }
        // else {
        //     var combos = new Combos { from: matrix };
        //     combos.initialize();
        //     combos.solve();
        //     print("[bad] solution: ", combos.best);
        // }

        //if k > 4 { break; }

        // if puzzle.joltages.length >= puzzle.buttons.length {
        //     print("---");
        //     matrix.print_me();
        //     print("--- rref ---");
        //     matrix.rref();
        //     matrix.print_me();
        //     break;
        // }
        // if puzzle.joltages.length < puzzle.buttons.length {
        //     print("---");
        //     for i in 0..puzzle.joltages.length {
        //         var row = str("");
        //         for j in 0..puzzle.buttons.length {
        //             //print(i, " ", j, " ", puzzle.buttons[j].elems[i]);
        //             row = str(row, ", ", if puzzle.buttons[j].elems[i] { 1 } else { 0 });
        //             //print(row);
        //         }
        //         print(row, ", ", puzzle.joltages[i]);
        //     }
        // }
    }

    print("sum: ", sum, "; sum2: ", sum2);
}
