var ZERO    = "0"[0];
var NINE    = "9"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

var LBRACKET = "["[0];
var RBRACKET = "]"[0];
var DOT = "."[0];
var HASH = "#"[0];

var LPAREN = "("[0];
var RPAREN = ")"[0];
var COMMA  = ","[0];
var LBRACE = "{"[0];
var RBRACE = "}"[0];

class Box {
    var elems: DynArray[bool] = [];
}

// return int for ==...
fun is_even(x: int) -> int {
    while x > 0 {
        x = x - 2;
    }
    // odd
    if x < 0 { 0 } else { 1 }
}

class Solution {
    var best: int = 10000000000;
    var has_solution: bool = false;

    fun is_le(attempt: DynArray[int], real: DynArray[int]) -> bool {
        for i in 0..attempt.length {
            if attempt[i] > real[i] { return false; }
        }
        return true;
    }

    fun is_solution(attempt: DynArray[int], real: DynArray[int]) -> bool {
        for i in 0..attempt.length {
            if attempt[i] != real[i] { return false; }
        }
        return true;
    }

    fun incr(attempt: DynArray[int], button: Box, by: int) {
        for i in 0..attempt.length {
            if button.elems[i] {
                attempt[i] = attempt[i] + by;
            }
        }
    }

    fun decr(attempt: DynArray[int], button: Box, by: int) {
        for i in 0..attempt.length {
            if button.elems[i] {
                attempt[i] = attempt[i] - by;
            }
        }
    }

    // At the given index of button, try increasing all the values
    // in our attempted solution, until we overshoot.
    //
    // If the solution ended up correct, yippee.
    fun dfs(attempt: DynArray[int], puzzle: Puzzle, idx: int, num_pressed: int) {
        if idx >= puzzle.buttons.length {
            return;
        }
        var button = puzzle.buttons[idx];

        var my_presses = 0;

        while (my_presses + num_pressed < best) and is_le(attempt, puzzle.joltages) {
            incr(attempt, button, 1);
            //print("[", idx, " - ", num_pressed, "] attempt: ", attempt[0], " ", attempt[1], " ", attempt[2], " ", attempt[3], " ", attempt[4], " ", attempt[5]);
            my_presses = my_presses + 1;
        }
        decr(attempt, button, 1);
        my_presses = my_presses - 1;

       // print("[", idx, "] starting presses: ", my_presses);

        // Now, while we still have any presses left, check for solutions.
        while my_presses > 0 {
            if is_solution(attempt, puzzle.joltages) {
                if my_presses + num_pressed < best {
                    best = my_presses + num_pressed;
                    has_solution = true;
                }
            }
            dfs(attempt, puzzle, idx + 1, num_pressed + my_presses);

            // Then, decrement.
            my_presses = my_presses - 1;
            decr(attempt, button, 1);
        }
    }

    fun solve_for(puzzle: Puzzle) {
        // Initialize our attempt array.
        //
        // We need exactly one button in it for each button in our solution.
        var attempt: DynArray[int] = [];
        for i in 0..puzzle.joltages.length {
            attempt.push(0);
        }

        var num_pressed = 0;

        dfs(attempt, puzzle, 0, num_pressed);
    }
}

class Puzzle {
    var box: Box = new Box{};
    var buttons: DynArray[Box] = [];
    var joltages: DynArray[int] = [];
}

class Text {
    var text: StrBuf = "";
    var idx : int    = 0;

    fun box() -> Box? {
        while idx < text.length and text[idx] != LBRACKET {
            idx = idx + 1;
        }
        if idx >= text.length {
            return nil;
        }

        // Skip the [
        idx = idx + 1;
        var box = new Box{};
        while text[idx] != RBRACKET {
            box.elems.push(text[idx] == HASH);
            idx = idx + 1;
        }

        // Skip the ]
        idx = idx + 1;

        box
    }

    fun button(other: Box) -> Box? {
        while text[idx] != LPAREN and text[idx] != LBRACE {
            idx = idx + 1;
        } 

        // No more buttons.
        if text[idx] == LBRACE { return nil; }

        var box = new Box{};
        for i in 0..other.elems.length {
            box.elems.push(false);
        }

        idx = idx + 1; // Get rid of LPAREN
        while text[idx] != RPAREN {
            var number = 0;
            while is_digit(text[idx]) {
                number = (number * 10 + text[idx] - ZERO);
                idx = idx + 1;
            }

            // Set the value in the button
            box.elems[number] = true;

            if text[idx] != RPAREN {
                idx = idx + 1; // Skip comma
            }
        }

        idx = idx + 1; // Skip rparen

        box
    }

    fun joltages() -> DynArray[int] {
        while text[idx] != LBRACE {
            idx = idx + 1;
        }

        var joltages: DynArray[int] = [];

        idx = idx + 1;
        while text[idx] != RBRACE {
            var number = 0;
            while is_digit(text[idx]) {
                number = (number * 10 + text[idx] - ZERO);
                idx = idx + 1;
            }

            joltages.push(number);

            if text[idx] != RBRACE {
                idx = idx + 1;
            }
        }

        joltages
    }
}

fun get_text() -> Text { new Text { text: read_file("input.txt") } }

fun init() {
    var text = get_text();
    var puzzles: DynArray[Puzzle] = [];
    loop {
        var box = text.box();
        var box = box else { break; };

        var puzzle = new Puzzle { box: box };
        loop {
            var button = text.button(box);
            puzzle.buttons.push(button else { break; });
        }

        var joltages = text.joltages();
        puzzle.joltages = joltages;

        puzzles.push(puzzle);
    }

    var sum = 0;
    for i in 0..puzzles.length {
        var puzzle = puzzles[i];
        //puzzle.solve_part_1();
        var solution = new Solution{};
        solution.solve_for(puzzle);
        print(solution.best);

        sum = sum + solution.best;
    }

    print(sum);
}
