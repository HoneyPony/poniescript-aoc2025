var ZERO    = "0"[0];
var NINE    = "9"[0];
var SPACE   = " "[0];
var NEWLINE = "\n"[0];
var PLUS    = "+"[0];
var STAR    = "*"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

fun is_not_digit(c: int) -> bool {
    c < ZERO or c > NINE
}

class GraphSize {
    var size: int = 0;
    var used: bool = false;
}

class Box {
    var id: int = 0;
    var pos: vec3i = (0, 0, 0);

    var connected: ConnectList = new ConnectList{};
    var connected2: ConnectList = new ConnectList{};

    var size: GraphSize? = nil;

    var visited: bool = false;
    var p_visited: bool = false;

    fun print_graph() -> StrBuf {
        if p_visited { return ""; }
        p_visited = true;

        var s = str(id, " ");
        var iter = connected.head;

        loop {
            var item = iter else { break; };

            var other = get_other(item);
            s = str(s, other.print_graph());

            iter = item.next2;
        }

        s
    }

    fun compute_graph_size() -> int {
        visited = true;

        var size_ = 1;

        var iter = connected.head;

        loop {
            var item = iter else { break; };

            var other = get_other(item);
            if not_(other.visited) {
                size_ = size_ + other.compute_graph_size();
            }

            iter = item.next2;
        }

        var iter = connected2.head;

        loop {
            var item = iter else { break; };

            var other = get_other(item);
            if not_(other.visited) {
                size_ = size_ + other.compute_graph_size();
            }

            iter = item.next3;
        }

        size_
    }

    fun has_size() -> bool {
        var s = size else { return false; };
        return true;
    }

    fun _set_graph(size_: GraphSize) {
        if not_(has_size()) {
            size = size_;
            var iter = connected.head;

            loop {
                var item = iter else { break; };

                var other = get_other(item);
                other._set_graph(size_);

                iter = item.next2;
            }

            return;
        }
    }

    fun get_graph_size() -> GraphSize {
        var existing = size else {
            //print("--- begin circuit ---");
            var size_ = compute_graph_size();
            //print("got ", size_);
            var size_ = new GraphSize { size: size_ };
            
            // cache this.
            _set_graph(size_);

            return size_;
        };
        existing
    }

    fun get_other(connect: Connect) -> Box {
        if connect.first.id == id { connect.second } else { connect.first }
    }

    // Linked list
    var next: Box? = nil;
}

class LinkedList {
    var head: Box? = nil;
    var tail: Box? = nil;

    fun push(node: Box) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next = node;
        tail = node;
    }
}

class Connect {
    var first: Box = new Box{};
    var second: Box = new Box{};
    var first_id: int = 0;
    var dist: float = 0;

    // Whether this connect has been used as a connection.
    var used: bool = false;

    // Whether this connect has been visited in DFS.
    // var visited: bool = false;

    // Linked list
    var next: Connect? = nil;
    
    // Other linked list
    var next2: Connect? = nil;

    // Other other linked list...?
    var next3: Connect? = nil;
}

class ConnectList {
    var head: Connect? = nil;
    var tail: Connect? = nil;

    fun push(node: Connect) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next = node;
        tail = node;
    }

    fun push2(node: Connect) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next2 = node;
        tail = node;
    }

    fun push3(node: Connect) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next3 = node;
        tail = node;
    }
}

class Text {
    var text: StrBuf = "";
    var idx = 0;

    fun number() -> (int, bool) {
        var x = 0;
        var got = false;

        while idx < text.length and is_digit(text[idx]) {
            x = (x * 10 + text[idx] - ZERO);
            got = true;

            idx = idx + 1;
        };

        while idx < text.length and is_not_digit(text[idx]) { idx = idx + 1; };

        (x, got)
    }

    fun box() -> Box? {
        var nums = [0, 0, 0];
        for i in 0..nums.length {
            var next = number();
            if next.1 {
                nums[i] = next.0;
            }
            else { return nil; }
        };

        new Box {
            pos: (nums[0], nums[1], nums[2])
        }
    }
}

fun read_text() -> Text { new Text { text: read_file("input.txt") } }

fun not_(b: bool) -> bool {
    if b { false } else { true }
}

fun find_best(small: ConnectList, big: ConnectList) -> Connect {
    fun find_best_impl(list: ConnectList) -> Connect {
        var iter = list.head;
        var best = list.head;
        var best = best else { return new Connect{}; };

        loop {
            var item = iter else { break; };

            if not_(item.used) {
                if best.used {
                    best = item;
                }
                else {
                    if best.dist > item.dist {
                        best = item;
                    }
                }
            }

            iter = item.next;
        }

        best
    }

    var best = find_best_impl(small);

    // If we used every single one, we have to make a pass through the big
    // connectlist.
    if best.used {
        best = find_best_impl(big);
    }

    // We used this one.
    best.used = true;

    best
}

fun do_best_sizes(list: LinkedList) {
    var iter = list.head;
    loop {
        var item = iter else { break; };
        // Reset all sizes.
        item.visited = false;
        item.p_visited = false;
        item.size = nil;

        iter = item.next;
    }

    var best_sizes = [0, 0, 0];
    var best = list.head else { return; };
    var iter = list.head;
    loop {
        var item = iter else { break; };

        var size = item.get_graph_size();
        if not_(size.used) {
            size.used = true;
            var size = size.size;

            if size > best_sizes[0] {
                best_sizes[2] = best_sizes[1];
                best_sizes[1] = best_sizes[0];
                best_sizes[0] = size;

                best = item;
            }
            else {
                if size > best_sizes[1] {
                    best_sizes[2] = best_sizes[1];
                    best_sizes[1] = size;
                }
                else {
                    if size > best_sizes[2] {
                        best_sizes[2] = size;
                    }
                }
            }
        }

        iter = item.next;
    }

    print(best.print_graph());

    print(best_sizes[0], " ", best_sizes[1], " ", best_sizes[2]);
    print(best_sizes[0] * best_sizes[1] * best_sizes[2]);
}

fun init() {
    var text = read_text();

    var list = new LinkedList{};
    var id = 1;
    loop {
        var box = text.box() else { break; };
        box.id = id;
        id = id + 1;
        list.push(box);
    }

    var iter = list.head;
    var small = new ConnectList{};
    var big = new ConnectList{};
    loop {
        var item = iter else { break; };
        
        // Connect all the ones *after* this one.
        var inner = item.next;
        loop {
            var inner_item = inner else { break; };
            var dist = inner_item.pos - item.pos;
            var dist = (dist.0 * dist.0 + dist.1 * dist.1 + dist.2 * dist.2);
           
            var connect = new Connect {
                first: item,
                first_id: item.id,
                second: inner_item,
                dist: dist
            };

            if dist < (10000 * 10000 * 3) {
                small.push(connect);
            }
            else {
                big.push(connect);
            }

            inner = inner_item.next;
        }

        iter = item.next;
    }

    var progress = 0;

    for i in 0..1000 {
        var best = find_best(small, big);

        best.first.connected.push2(best);
        best.second.connected2.push3(best);

        progress = progress + 1;
        if progress >= 10 {
            print("progress: ", i);
            progress = progress - 10;
        }
    }

    do_best_sizes(list);

    print("then");
}
