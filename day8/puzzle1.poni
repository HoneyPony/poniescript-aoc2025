var ZERO    = "0"[0];
var NINE    = "9"[0];
var SPACE   = " "[0];
var NEWLINE = "\n"[0];
var PLUS    = "+"[0];
var STAR    = "*"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

fun is_not_digit(c: int) -> bool {
    c < ZERO or c > NINE
}

class GraphSize {
    var size: int = 0;
    var used: bool = false;
}

class Box {
    var id: int = 0;
    var pos: vec3i = (0, 0, 0);

    var connected: ConnectList = new ConnectList{};
    var connected2: ConnectList = new ConnectList{};

    var size: GraphSize? = nil;

    var visited: bool = false;
    var p_visited: bool = false;

    fun print_graph() -> StrBuf {
        if p_visited { return ""; }
        p_visited = true;

        var s = str(id, " ");
        var iter = connected.head;

        loop {
            var item = iter else { break; };

            var other = get_other(item);
            s = str(s, other.print_graph());

            iter = item.next2;
        }

        s
    }

    fun compute_graph_size() -> int {
        visited = true;

        var size_ = 1;

        var iter = connected.head;

        loop {
            var item = iter else { break; };

            var other = get_other(item);
            if not_(other.visited) {
                size_ = size_ + other.compute_graph_size();
            }

            iter = item.next2;
        }

        var iter = connected2.head;

        loop {
            var item = iter else { break; };

            var other = get_other(item);
            if not_(other.visited) {
                size_ = size_ + other.compute_graph_size();
            }

            iter = item.next3;
        }

        size_
    }

    fun has_size() -> bool {
        var s = size else { return false; };
        return true;
    }

    fun _set_graph(size_: GraphSize) {
        if not_(has_size()) {
            size = size_;
            var iter = connected.head;

            loop {
                var item = iter else { break; };

                var other = get_other(item);
                other._set_graph(size_);

                iter = item.next2;
            }

            return;
        }
    }

    fun get_graph_size() -> GraphSize {
        var existing = size else {
            //print("--- begin circuit ---");
            var size_ = compute_graph_size();
            //print("got ", size_);
            var size_ = new GraphSize { size: size_ };
            
            // cache this.
            _set_graph(size_);

            return size_;
        };
        existing
    }

    fun get_other(connect: Connect) -> Box {
        if connect.first.id == id { connect.second } else { connect.first }
    }

    // Linked list
    var next: Box? = nil;
}

class LinkedList {
    var head: Box? = nil;
    var tail: Box? = nil;

    fun push(node: Box) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next = node;
        tail = node;
    }
}

class Connect {
    var first: Box = new Box{};
    var second: Box = new Box{};
    var first_id: int = 0;
    var dist: float = 0;

    // Whether this connect has been used as a connection.
    var used: bool = false;

    // Whether this connect has been visited in DFS.
    // var visited: bool = false;

    // Linked list
    var next: Connect? = nil;
    
    // Other linked list
    var next2: Connect? = nil;

    // Other other linked list...?
    var next3: Connect? = nil;
}

/// Returns the node pointing to term.
fun merge_sort(head: Connect, node: Connect, len: int, term: Connect?) -> Connect {
    if len <= 1 {
        // Already sorted.
        return node;
    }

    var half = len / 2;
    var first = node;
    var others = {
        var iter: Connect? = node;
        var prev = node;
        for i in 0..half {
            var item = iter else { break; };
            prev = item;
            iter = item.next;
        };
        (prev, iter else { print("uh oh (no second node)"); new Connect{} })
    };
    var second = others.1;

    var left_len  = half;
    var right_len = len - half;
    //print("sort: ", left_len, " ", right_len);

    var s = merge_sort(head    , first , left_len , second);
    merge_sort(s, second, right_len, term);

    // Now, merge the two sorted halves.
    var left_idx = 0;
    var right_idx = 0;
    var out = head;

    var left_read = head.next;
    var right_read = {
        var iter: Connect? = head;
        for i in 0..=half {
            var item = iter else { break; };
            iter = item.next;
        };
        iter
    };

    while left_idx < left_len or right_idx < right_len {
        var left = left_read else { print("uh oh (no left node)"); return node; };

        var use_left = false;
        if left_idx >= left_len { use_left = false; }
        else {
            if right_idx >= right_len { use_left = true; }
            else {
                var right = right_read else { print("uh oh (no right node)"); return node; };
                use_left = left.dist < right.dist;
            }
        }

        if use_left {
            out.next = left;
            out = left;
            left_read = left.next;
            left_idx = left_idx + 1;
        }
        else {
            var right = right_read else { print("uh oh (no right node)"); return node; };
            out.next = right;
            out = right;
            right_read = right.next;
            right_idx = right_idx + 1;
        }
    }

    // print("-- locally sorted --", len);
    // var iter = head.next;
    // for i in 0..len {
    //     var item = iter else { break; };
    //     print(item.dist);
    //     iter = item.next;
    // }

    out.next = term;
    return out;
}

class ConnectList {
    var head: Connect? = nil;
    var tail: Connect? = nil;

    fun push(node: Connect) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next = node;
        tail = node;
    }

    fun push2(node: Connect) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next2 = node;
        tail = node;
    }

    fun push3(node: Connect) {
        var tail_ = tail else {
            head = node;
            tail = node;
            return;
        };
        tail_.next3 = node;
        tail = node;
    }

    fun sort_with_dummy_node() {
        // Calculate initial len.
        var len = 0;
        var iter = head;
        loop {
            var item = iter else { break; };
            len = len + 1;
            iter = item.next;
        }
        
        var head = head else { return; };
        var first = head.next else { return; };

        print("merge sort: ", len - 1);
        merge_sort(head, first, len - 1, nil);
    }
}

class Text {
    var text: StrBuf = "";
    var idx = 0;

    fun number() -> (int, bool) {
        var x = 0;
        var got = false;

        while idx < text.length and is_digit(text[idx]) {
            x = (x * 10 + text[idx] - ZERO);
            got = true;

            idx = idx + 1;
        };

        while idx < text.length and is_not_digit(text[idx]) { idx = idx + 1; };

        (x, got)
    }

    fun box() -> Box? {
        var nums = [0, 0, 0];
        for i in 0..nums.length {
            var next = number();
            if next.1 {
                nums[i] = next.0;
            }
            else { return nil; }
        };

        new Box {
            pos: (nums[0], nums[1], nums[2])
        }
    }
}

fun read_text() -> Text { new Text { text: read_file("input.txt") } }

fun not_(b: bool) -> bool {
    if b { false } else { true }
}

fun find_best(small: ConnectList, big: ConnectList) -> Connect {
    fun find_best_impl(list: ConnectList) -> Connect {
        var iter = list.head;
        var best = list.head;
        var best = best else { return new Connect{}; };

        loop {
            var item = iter else { break; };

            if not_(item.used) {
                if best.used {
                    best = item;
                }
                else {
                    if best.dist > item.dist {
                        best = item;
                    }
                }
            }

            iter = item.next;
        }

        best
    }

    var best = find_best_impl(small);

    // If we used every single one, we have to make a pass through the big
    // connectlist.
    if best.used {
        best = find_best_impl(big);
    }

    // We used this one.
    best.used = true;

    best
}

fun do_best_sizes(list: LinkedList) {
    var iter = list.head;
    loop {
        var item = iter else { break; };
        // Reset all sizes.
        item.visited = false;
        item.p_visited = false;
        item.size = nil;

        iter = item.next;
    }

    var best_sizes = [0, 0, 0];
    var best = list.head else { return; };
    var iter = list.head;
    loop {
        var item = iter else { break; };

        var size = item.get_graph_size();
        if not_(size.used) {
            size.used = true;
            var size = size.size;

            if size > best_sizes[0] {
                best_sizes[2] = best_sizes[1];
                best_sizes[1] = best_sizes[0];
                best_sizes[0] = size;

                best = item;
            }
            else {
                if size > best_sizes[1] {
                    best_sizes[2] = best_sizes[1];
                    best_sizes[1] = size;
                }
                else {
                    if size > best_sizes[2] {
                        best_sizes[2] = size;
                    }
                }
            }
        }

        iter = item.next;
    }

    print(best.print_graph());

    print(best_sizes[0], " ", best_sizes[1], " ", best_sizes[2]);
    print(best_sizes[0] * best_sizes[1] * best_sizes[2]);
}

fun init() {
    var text = read_text();

    var list = new LinkedList{};
    var id = 1;
    loop {
        var box = text.box() else { break; };
        box.id = id;
        id = id + 1;
        list.push(box);
    }

    var iter = list.head;
    // var small = new ConnectList{};
    // var big = new ConnectList{};
    var all = new ConnectList{};
    all.push(new Connect{}); // dummy node
    loop {
        var item = iter else { break; };
        
        // Connect all the ones *after* this one.
        var inner = item.next;
        loop {
            var inner_item = inner else { break; };
            var dist = inner_item.pos - item.pos;
            var dist = (dist.0 * dist.0 + dist.1 * dist.1 + dist.2 * dist.2);
           
            var connect = new Connect {
                first: item,
                first_id: item.id,
                second: inner_item,
                dist: dist
            };

            all.push(connect);

            inner = inner_item.next;
        }

        iter = item.next;
    }

    all.sort_with_dummy_node();

    // var iter = all.head;
    // loop {
    //     var item = iter else { break; };
    //     print("sorted: ", item.dist);
    //     iter = item.next;
    // }

    // return;

    var progress = 0;

    var best = all.head;
    var best = best else { print("no best?"); return; };

    for i in 0..1000 {
        best.first.connected.push2(best);
        best.second.connected2.push3(best);

        progress = progress + 1;
        if progress >= 10 {
            print("progress: ", i);
            progress = progress - 10;
        }

        best = best.next else { print("ran out of nodes"); break; };
    }

    do_best_sizes(list);

    print("then");
}
