var ZERO    = "0"[0];
var NINE    = "9"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

fun is_not_digit(c: int) -> bool {
    c < ZERO or c > NINE
}

class Text {
    // Note: Putting the read_text() directly here lead to an internal C error.
    var text: StrBuf = "";
    var idx = 0;

    fun number() -> (int, bool) {
        if idx >= text.length { return (0, false); }

        var number = 0;
        while is_digit(text[idx]) {
            number = (number * 10 + text[idx] - ZERO);
            idx = idx + 1;
        }

        while idx < text.length and is_not_digit(text[idx]) { idx = idx + 1; };

        (number, true)
    }

    fun pair() -> (vec2i, bool) {
        var a = number();
        var b = number();
        if a.1 and b.1 {
            return ((a.0, b.0), false);
        }
        return ((0, 0), true);
    }
}

fun get_text() -> Text { new Text { text: read_file("input.txt") } }

fun not_(x: bool) -> bool { if x { false } else { true } }

fun init() {
    var points: DynArray[vec2i] = [];
    var dirs: DynArray[(vec2i, int)] = [];
    //var pairs: DynArray[(vec2i, vec2i)] = [];
    var text = get_text();

    loop {
        var next = text.pair();
        if next.1 { break; };

        points.push((next.0));
    }

    fun sign(x: int) -> int {
        if x < 0 { return -1; }
        if x > 0 { return 1; }
        return 0;
    }

    fun sign2(x: vec2i) -> vec2i {
        (sign(x.0), sign(x.1))
    }

    fun rotation(prev: vec2i, next: vec2i) -> int{
        if prev.0 == next.0 and prev.1 == next.1 {
            return 0;
        }
        // Parse sadness: This == is parsed wrong without the ()
        if (prev.0 == -next.1) and prev.1 == next.0 {
            return 1;
        }
        if prev.0 == next.1 and prev.1 == -next.0 {
            return -1;
        }
        /// This is bad.
        print("uh oh");
        return 0;
    }

    var winding: int = 0;

    for i in 0..points.length {
        var prev = i - 1;
        if prev < 0 { prev = prev + points.length; }
        var next = i + 1;
        if next >= points.length { next = next - points.length; }

        var back = sign2(points[i] - points[prev]);
        var forth = sign2(points[next] - points[i]);

        var rot = rotation(back, forth);
        winding = winding + rot;

        var dir = (points[prev] - points[i]) + (points[next] - points[i]);

        //var dir = sign2(points[prev] - points[i]) + sign2(points[next] - points[i]);
        // This doesn't work :(
        //points[i].1 = dir;
        dirs.push((dir, rot));

        //print(dir, " ", dirs[i]);
        //print(winding);
    }
    print(winding);

    fun abs(x: int) -> int {
        if x < 0 { -x } else { x } 
    }

    var best = 0;

    winding = sign(winding);

    fun min(a: int, b: int) -> int { if a < b { a } else { b } }
    fun max(a: int, b: int) -> int { if a > b { a } else { b } }

    fun is_good_v2(a: vec2i, b: vec2i, points: DynArray[vec2i]) -> bool {
        //print("candidate: ", a, " ", b);
        var low  = (min(a.0, b.0), min(a.1, b.1));
        var high = (max(a.0, b.0), max(a.1, b.1));

        //print(low, high);

        for i in 0..points.length {
            var next = i + 1;
            if next >= points.length { next = next - points.length; }

            var p: vec2i = points[i];
            var u: vec2i = points[next];

            fun same(x: vec2i, y: vec2i) -> bool {
                x.0 == y.0 and x.1 == y.1;
            }
            
            var ok = same(p, a) or same(u, a) or same(p, b) or same(u, b);

            if p.0 == u.0 {
                // Vertical line. It is bad if the X position is
                // strictly inside, and either Y position is strictly inside,
                // OR both y positions are outside.
                if p.0 > low.0 and p.0 < high.0 {
                    var p_strict = (p.1 > low.1 and p.1 < high.1);
                    var u_strict = (u.1 > low.1 and u.1 < high.1);

                    var pu_min = min(u.1, p.1);
                    var pu_max = max(u.1, p.1);

                    var span = (pu_min <= low.1 and pu_max >= high.1);

                    if (p_strict or u_strict or span) {
                        return false;
                    }
                }
            }

            if p.1 == u.1 {
                if p.1 > low.1 and p.1 < high.1 {
                    var p_strict = (p.0 > low.0 and p.0 < high.0);
                    var u_strict = (u.0 > low.0 and u.0 < high.0);

                    var pu_min = min(u.0, p.0);
                    var pu_max = max(u.0, p.0);

                    var span = (pu_min <= low.0 and pu_max >= high.0);

                    if (p_strict or u_strict or span) {
                        return false;
                    }
                }
            }
        }

        true
    }

    fun is_good(a: vec2i, b: vec2i, points: DynArray[vec2i]) -> bool {
        var low = (min(a.0, b.0), min(a.1, b.1));
        var high = (max(a.0, b.0), max(a.1, b.1));
        for i in 0..points.length {
            var p = points[i];

            var next = i + 1;
            if next >= points.length { next = next - points.length; }

            var u = points[next];

            var step = ((sign(u.0 - p.0)), sign(u.1 - p.1));
            var count = abs(u.0 - p.0) + abs(u.1 - p.1);

            for j in 0..count {
                var a = p.0 > low.0 and p.0 < high.0;
                //var b = p.0 >= low.0 and p.0 <= high.0;
                var c = p.1 > low.1 and p.1 < high.1;
                //var d = p.1 >= low.1 and p.1 <= high.1;
                if a and c {
                    return false;
                }

                p = p + step;
            }
        }

        true
    }

    for i in 0..points.length {
        for j in i + 1..points.length {
            var ap = points[i];
            var bp = points[j];

            // fun compat(dir: int, check: int) -> bool {
            //     // No opinion.
            //     if dir == 0 { return true; }
            //     return sign(dir) == sign(check);
            // }

            // fun compat2(dir: vec2i, check: vec2i) -> bool {
            //     compat(dir.0, check.0) and compat(dir.1, check.1)
            // }

            // fun compat3(dir: (vec2i, int), check: vec2i, flag: int) -> bool {
            //     if dir.1 == flag {
            //         compat2(dir.0, check)
            //     }
            //     else {
            //         compat2((-dir.0.0, -dir.0.1), check) and
            //             compat2(( dir.0.1, -dir.0.0), check) and
            //             compat2((-dir.0.1,  dir.0.0), check)
            //     }
            // }

            fun signmatch2(a: vec2i, b: vec2i) -> bool {
                sign(a.0) == sign(b.0) and sign(a.1) == sign(b.1)
            }

            fun funny_predicate(x: int, dir: int) -> bool {
                x == 0 or (sign(x) == -sign(dir))
            }

            fun other_predicate(x: int, dir: int) -> bool {
                x == 0 or sign(x) == sign(dir)
            }

            fun compat(point: vec2i, to: vec2i, dir: (vec2i, int), flag: int) -> bool {
                if dir.1 == flag {
                    var vec = to - point;
                    return signmatch2(vec, dir.0);
                }
                var v = to - (point + dir.0);
                var u = to - point;
                return (funny_predicate(v.0, dir.0.0) and other_predicate(u.1, dir.0.1)) or
                    (other_predicate(u.0, dir.0.0) and funny_predicate(v.1, dir.0.1));
            }

            // var dir_a_to_b = bp - ap;
            // var dir_b_to_a = ap - bp;
            // var valid = compat3(dirs[i], dir_a_to_b, winding) and compat3(dirs[j], dir_b_to_a, winding);//compat2(dirs[i], dir_a_to_b) and compat2(dirs[i], dir_b_to_a);
            //print(valid);

            // as per input-me3, positive winding is correct...?
            var valid = compat(ap, bp, dirs[i], winding)
                 and compat(bp, ap, dirs[j], winding);
            
            if valid {
                var area = (abs(ap.0 - bp.0) + 1) * (abs(ap.1 - bp.1) + 1);
                //print(a, " ", b, " => ", area);
                if area > best {
                    //print("will try: ", ap, " ", bp);
                    // Now check the expensive one.
                    if is_good_v2(ap, bp, points) {
                        print("new best: ", ap, " ", bp);
                        best = area;
                    }
                }
            }
        }
        //print("complete: ", i);
    }

    print(best);
}
