var ZERO    = "0"[0];
var NINE    = "9"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

fun is_not_digit(c: int) -> bool {
    c < ZERO or c > NINE
}

class Text {
    // Note: Putting the read_text() directly here lead to an internal C error.
    var text: StrBuf = "";
    var idx = 0;

    fun number() -> (int, bool) {
        if idx >= text.length { return (0, false); }

        var number = 0;
        while is_digit(text[idx]) {
            number = (number * 10 + text[idx] - ZERO);
            idx = idx + 1;
        }

        while idx < text.length and is_not_digit(text[idx]) { idx = idx + 1; };

        (number, true)
    }

    fun pair() -> (vec2i, bool) {
        var a = number();
        var b = number();
        if a.1 and b.1 {
            return ((a.0, b.0), false);
        }
        return ((0, 0), true);
    }
}

fun get_text() -> Text { new Text { text: read_file("input-me3.txt") } }

fun not_(x: bool) -> bool { if x { false } else { true } }

fun init() {
    var points: DynArray[vec2i] = [];
    var text = get_text();

    loop {
        var next = text.pair();
        if next.1 { break; };

        points.push((next.0));
    }

    fun sign(x: int) -> int {
        if x < 0 { return -1; }
        if x > 0 { return 1; }
        return 0;
    }

    fun sign2(x: vec2i) -> vec2i {
        (sign(x.0), sign(x.1))
    }

    fun abs(x: int) -> int {
        if x < 0 { -x } else { x } 
    }

    var best = 0;

    fun min(a: int, b: int) -> int { if a < b { a } else { b } }
    fun max(a: int, b: int) -> int { if a > b { a } else { b } }

    fun edge_overlaps(a: (vec2i, vec2i), b: (vec2i, vec2i)) -> bool {
        if a.0.0 == a.1.0 {
            if b.0.0 == b.1.0 {
                return false;
            }

            // a is vertical, b is horizontal
            var low_y = min(a.0.1, a.1.1);
            var high_y = max(a.0.1, a.1.1);

            var low_x = min(b.0.0, b.1.0);
            var high_x = max(b.0.0, b.1.0);
            
            return a.0.0 >= low_x and a.0.0 <= high_x and b.0.1 >= low_y and b.0.1 <= high_y;
        }
        else {
            if b.0.1 == b.1.1 {
                return false;
            }

            var low_y = min(b.0.1, b.1.1);
            var high_y = max(b.0.1, b.1.1);

            var low_x = min(a.0.0, a.1.0);
            var high_x = max(a.0.0, a.1.0);
            
            return b.0.0 >= low_x and b.0.0 <= high_x and a.0.1 >= low_y and a.0.1 <= high_y;
        }
    }

    fun is_good(a: vec2i, b: vec2i, points: DynArray[vec2i]) -> bool {
        print("-- ", a, " ", b);
        var edges = [
            ((a.0, a.1), (a.0, b.1)),
            ((a.0, b.1), (b.0, b.1)),
            ((b.0, b.1), (b.0, a.1)),
            ((b.0, a.1), (a.0, a.1))
        ];

        for i in 0..points.length {
            var next = i + 1;
            if next >= points.length { next = next - points.length; }

            var edge = (points[i], points[next]);
            for j in 0..edges.length {
                var o = edge_overlaps(edge, edges[j]);
                print(edge, " ", edges[j], " ", o);
                if o {
                    return false;
                }
            }
        }

        true
    }

    for i in 0..points.length {
        for j in i + 1..points.length {
            var ap = points[i];
            var bp = points[j];
            
            var area = (abs(ap.0 - bp.0) + 1) * (abs(ap.1 - bp.1) + 1);
            //print(a, " ", b, " => ", area);
            if area > best {
                //print("will try: ", ap, " ", bp);
                // Now check the expensive one.
                if not_(is_good(ap, bp, points)) {
                    print("new best: ", ap, " ", bp);
                    best = area;
                }
            }
        }
    }

    print(best);
}
