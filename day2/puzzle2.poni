var ZERO = "0"[0];
var NINE = "9"[0];
var DASH = "-"[0];
var COMMA = ","[0];

fun is_digit(char: int) -> bool {
    char >= ZERO and char <= NINE
}

// For the lows, we want to *underestimate* the size. This is done by nudging
// j forward by 1. For the highs, we want to *overeestimate*. This is done by
// nudging j backward by 1.
fun get_split_val_generic(s: StrBuf, divider: int, nudge: int, predicate: fun(int, int) -> bool) -> int {
    //var s = str(val);
    var i = 0;
    var step = s.length / divider;

    if step * divider != s.length {
        // Overestimate the size of the thing to check.
        step = step + nudge;
    }

    // Edge cases...
    if step == 0 {
        return 0;
    }

    var result = 0;
    var flag = true;

    while i < s.length {
        var next_num = 0;
        var j = 0;
        while j < step {
            next_num = next_num * 10;
            next_num = next_num + s[i] - ZERO;
            j = j + 1;
            i = i + 1;
        }

        if flag or predicate(next_num, result) {
            result = next_num;
            flag = false;
        }
    };

    result
}

fun get_split_val_max(s: StrBuf, divider: int) -> int {
    get_split_val_generic(s, divider, 1, fun(x: int, y: int) -> bool { x > y })
}

fun get_split_val_min(s: StrBuf, divider: int) -> int {
    get_split_val_generic(s, divider, 0, fun(x: int, y: int) -> bool { x < y })
}

fun num_repeat(num_i: int, divider: int) -> int {
    var pow = 0;
    var num = num_i;
    while num > 0 {
        num = num / 10;
        pow = pow + 1;
    }
    var result = num_i;

    // Compute shift value
    var shift = 1;
    while pow > 0 {
        shift = shift * 10;
        pow = pow - 1;
    }

    var i = 1;
    while i < divider {
        result = result * shift;
        result = result + num_i;

        i = i + 1;
    }

    result
}

fun is_number_divideable(num: StrBuf, divider: int) -> bool {
    var step = num.length / divider;
    // Must evenly divide for this to work.
    if step * divider != num.length {
        return false;
    }

    var i = 0;
    while i < step {
        var check = num[i];
        var j = 1;
        while j < divider {
            if num[i + j * step] != check {
                return false;
            }
            j = j + 1;
        }
        i = i + 1;
    }

    return true;
}

/// Computes the number of repetitions that the given number can be created with,
/// that is the smallest.
fun get_smallest_divider(s: StrBuf) -> int {
    var divider = 2;

    //var s = str(num);
    while divider < s.length {
        if is_number_divideable(s, divider) {
            return divider;
        }

        divider = divider + 1;
    };

    // Should be unreachable.
    divider
}

fun do_it() {
    var contents = read_file("input.txt");

    var i = 0;
    var sum = 0;
    while i < contents.length {
        var num1 = 0;
        while contents[i] != DASH {
            num1 = num1 * 10;
            num1 = num1 + contents[i] - ZERO;
            i = i + 1;
        }
        i = i + 1;
        var num2 = 0;
        while i < contents.length and is_digit(contents[i]) {
            num2 = num2 * 10;
            num2 = num2 + contents[i] - ZERO;
            i = i + 1;
        }
        i = i + 1;

        // print(num1, " -> ", num2);

        var num1s = str(num1);
        var num2s = str(num2);

        // If both numbers are the same length, don't check dividers that
        // don't work for them.
        var do_early_exits = num1s.length == num2s.length or (num1s.length + 1 == num2s.length);

        var max_possible = num2s.length;

        var count = 0;
    
        var divider = 2;
        while divider <= max_possible {
            var actually = true;
            if do_early_exits {
                if (num1s.length / divider) * divider != num1s.length {
                    actually = false;
                }
                if (num2s.length / divider) * divider != num2s.length {
                    actually = false;
                }
                0;
            }

            if actually {
                var start = get_split_val_min(num1s, divider);
                var end = get_split_val_max(num2s, divider);

                var check = start;
                while check <= end {
                    //var check_s = str(check);
                    var candidate = num_repeat(check, divider);

                    if candidate >= num1 and candidate <= num2 {
                        //print("got @ ", divider, ": ", candidate);
                        var d = get_smallest_divider(str(candidate));
                        if d == divider {
                            sum = sum + candidate;
                            count = count + 1;
                        }
                        0;
                    }

                    check = check + 1;
                };

                
                0;
           }
           divider = divider + 1;
        }

        // print("got ", count, " candidates");
    }

    print("sum: ", sum);
}

fun init() {
    var i = 0;
    while i < 1000 {
        do_it();
        i = i + 1;
    }
}