var ZERO = "0"[0];
var NINE = "9"[0];
var DASH = "-"[0];
var COMMA = ","[0];

fun is_digit(char: int) -> bool {
    char >= ZERO and char <= NINE
}

fun min(tup: (int, int)) -> int {
    lerp(tup.0, tup.1, tup.1 < tup.0)
}

fun max(tup: (int, int)) -> int {
    lerp(tup.0, tup.1, tup.1 > tup.0)
}

// For the lows, we want to *underestimate* the size. This is done by nudging
// j forward by 1. For the highs, we want to *overeestimate*. This is done by
// nudging j backward by 1.
fun get_split_val_min(val: int, divider: int) -> int {
    var s = str(val);
    var i = 0;
    var step = s.length / divider;

    var result = 10000000;

    while i < s.length {
        var next_num = 0;
        var j = 0;
        while j < step {
            next_num = next_num * 10;
            next_num = next_num + s[i] - ZERO;
            j = j + 1;
            i = i + 1;
        }

        if next_num < result {
            result = next_num;
        }
    };

    result
}

fun get_split_val_max(val: int, divider: int) -> int {
    var s = str(val);
    var i = 0;
    var step = s.length / divider;

    if step * divider != s.length {
        // Overestimate the size of the thing to check.
        step = step + 1;
    }

    var result = -1;

    while i < s.length {
        var next_num = 0;
        var j = 0;
        while j < step {
            next_num = next_num * 10;
            next_num = next_num + s[i] - ZERO;
            j = j + 1;
            i = i + 1;
        }

        if next_num > result {
            result = next_num;
        }
    };

    result
}

fun num_repeat(num: int, divider: int) -> int {
    var pow = str(num).length;
    var result = num;

    // Compute shift value
    var shift = 1;
    while pow > 0 {
        shift = shift * 10;
        pow = pow - 1;
    }

    var i = 1;
    while i < divider {
        result = result * shift;
        result = result + num;

        i = i + 1;
    }

    result
}

fun is_number_divideable(num: StrBuf, divider: int) -> bool {
    var step = num.length / divider;
    // Must evenly divide for this to work.
    if step * divider != num.length {
        return false;
    }

    var i = 0;
    while i < step {
        var check = num[i];
        var j = 1;
        while j < divider {
            if num[i + j * step] != check {
                return false;
            }
            j = j + 1;
        }
        i = i + 1;
    }

    return true;
}

/// Computes the number of repetitions that the given number can be created with,
/// that is the smallest.
fun get_smallest_divider(num: int) -> int {
    var divider = 2;

    var s = str(num);
    while divider < s.length {
        if is_number_divideable(s, divider) {
            return divider;
        }

        divider = divider + 1;
    };

    // Should be unreachable.
    divider
}

fun init() {
    var contents = read_file("input-help.txt");

    var i = 0;
    var sum = 0;
    while i < contents.length {
        var num1 = 0;
        while contents[i] != DASH {
            num1 = num1 * 10;
            num1 = num1 + contents[i] - ZERO;
            i = i + 1;
        }
        i = i + 1;
        var num2 = 0;
        while i < contents.length and is_digit(contents[i]) {
            num2 = num2 * 10;
            num2 = num2 + contents[i] - ZERO;
            i = i + 1;
        }
        i = i + 1;

        print(num1, " -> ", num2);

        var max_possible = str(num2).length;

        var count = 0;
    
        var divider = 2;
        while divider < max_possible {
            var start = get_split_val_min(num1, divider);
            var end = get_split_val_max(num2, divider);

            var check = start;
            while check <= end {
                var candidate = num_repeat(check, divider);

                if candidate >= num1 and candidate <= num2 {
                    print("got @ ", divider, ": ", candidate);
                    var d = get_smallest_divider(candidate);
                    if d == divider {
                        sum = sum + candidate;
                        count = count + 1;
                    }
                    0;
                }

                check = check + 1;
            };

            divider = divider + 1;
        }

        print("got ", count, " candidates");

        // For debugging
        //if i > 40 { break; }

        //print("lows: ", lows.0, " ", lows.1);
        //print("highs: ", highs.0, " ", highs.1);
        //var check = num1;
        //while check <= num2 {
        //    if is_sneaky(check) {
                //print("sneaky: ", check);
        //        sum = sum + check;
        //    }
        //    check = check + 1;
        //}
    }

    print("sum: ", sum);
}