var HASH = "#"[0];
var ZERO = "0"[0];
var NINE = "9"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

fun is_not_digit(c: int) -> bool {
    c < ZERO or c > NINE
}

class Text {
    var text: StrBuf = "";
    var idx : int    = 0;

    var numbers: Array[int] = [0, 0, 0, 0, 0, 0, 0, 0];

    fun shape() -> Shape {
        idx = idx + 3;

        var s = new Shape {};
        var k = 0;

        for i in 0..3 {
            for j in 0..3 {
                s.array[k] = (text[idx] == HASH);
                if s.array[i] {
                    s.count = s.count + 1;
                }
                idx = idx + 1;
                k = k + 1;
            }
            idx = idx + 1; // skip newline
        }
        idx = idx + 1;

        s
    }

    fun problem() -> Problem? {
        if idx >= text.length {
            return nil;
        }

        for i in 0..numbers.length {
            while is_not_digit(text[idx]) {
                idx = idx + 1;       
            }

            var val = 0;
            while is_digit(text[idx]) {
                val = (val * 10 + text[idx] - ZERO);
                idx = idx + 1;
            }

            while idx < text.length and is_not_digit(text[idx]) {
                idx = idx + 1;       
            }

            numbers[i] = val;
        }

        var p = new Problem{};
        p.size = (numbers[0], numbers[1]);
        for i in 2..numbers.length {
            p.counts[i - 2] = numbers[i];
        }
        p
    }
}

class Shape {
    var array: Array[bool] = 
       [false, false, false,
        false, false, false,
        false, false, false];

    var count: int = 0;

    fun debug() {
        fun r(b: bool) -> StrConst { lerp(".", "#", b) }
        print(
            r(array[0]), r(array[1]), r(array[2]), "\n",
            r(array[3]), r(array[4]), r(array[5]), "\n",
            r(array[6]), r(array[7]), r(array[8])
        )
    }
}

class Grid {
    var size: vec2i = (0, 0);
    var grid: DynArray[StrConst] = [];

    var widths = [3, 3, 3, 3, 3, 3, 6, 5, 4];

    var shapes = [
        fun shape0(x: int, y: int, grid: Grid) {
            grid.do_char3(x, y    , "0", "#", ".");
            grid.do_char3(x, y + 1, "#", "#", "#");
            grid.do_char3(x, y + 2, "#", ".", "#");
        },
        fun shape1(x: int, y: int, grid: Grid) {
            grid.do_char3(x, y    , "1", "#", "#");
            grid.do_char3(x, y + 1, "#", "#", "#");
            grid.do_char3(x, y + 2, ".", ".", "#");
        },
        fun shape2(x: int, y: int, grid: Grid) {
            grid.do_char3(x, y    , "2", "#", "#");
            grid.do_char3(x, y + 1, ".", ".", "#");
            grid.do_char3(x, y + 2, "#", "#", "#");
        },
        fun shape3(x: int, y: int, grid: Grid) {
            grid.do_char3(x, y    , "3", ".", ".");
            grid.do_char3(x, y + 1, "#", "#", ".");
            grid.do_char3(x, y + 2, "#", "#", "#");
        },
        fun shape4(x: int, y: int, grid: Grid) {
            grid.do_char3(x, y    , "4", ".", "#");
            grid.do_char3(x, y + 1, "#", "#", "#");
            grid.do_char3(x, y + 2, "#", ".", "#");
        },
        fun shape5(x: int, y: int, grid: Grid) {
            grid.do_char3(x, y    , "5", ".", ".");
            grid.do_char3(x, y + 1, "#", "#", ".");
            grid.do_char3(x, y + 2, ".", "#", "#");
        },

        fun shape6(x: int, y: int, grid: Grid) {
            grid.do_char6(x, y    , "1", "@", "5", "3", "&", "&");
            grid.do_char6(x, y + 1, "@", "@", "$", "$", "&", "&");
            grid.do_char6(x, y + 2, "@", "@", "@", "$", "$", "&");
        },

        fun shape7(x: int, y: int, grid: Grid) {
            grid.do_char5(x, y    , "1", "<", "0", "*", "*");
            grid.do_char5(x, y + 1, "<", "<", "*", "*", ".");
            grid.do_char5(x, y + 2, "<", "<", "<", "*", "*");
        },

        fun shape8(x: int, y: int, grid: Grid) {
            grid.do_char4(x, y    , ".", "2", "%", "%");
            grid.do_char4(x, y + 1, "2", "=", "=", "%");
            grid.do_char4(x, y + 2, "=", "%", "%", "%");
            grid.do_char4(x, y + 3, "=", "=", "=", ".");
        },
    ];

    fun do_char3(x: int, y: int, chara: StrConst, charb: StrConst, charc: StrConst) {
        do_char(x    , y, chara);
        do_char(x + 1, y, charb);
        do_char(x + 2, y, charc);
    }

    fun do_char4(x: int, y: int, chara: StrConst, charb: StrConst, charc: StrConst, chard: StrConst) {
        do_char(x    , y, chara);
        do_char(x + 1, y, charb);
        do_char(x + 2, y, charc);
        do_char(x + 3, y, chard);
    }

    fun do_char5(x: int, y: int, chara: StrConst, charb: StrConst, charc: StrConst, chard: StrConst, chare: StrConst) {
        do_char(x    , y, chara);
        do_char(x + 1, y, charb);
        do_char(x + 2, y, charc);
        do_char(x + 3, y, chard);
        do_char(x + 4, y, chare);
    }

    fun do_char6(x: int, y: int, chara: StrConst, charb: StrConst, charc: StrConst, chard: StrConst, chare: StrConst, charf: StrConst) {
        do_char(x    , y, chara);
        do_char(x + 1, y, charb);
        do_char(x + 2, y, charc);
        do_char(x + 3, y, chard);
        do_char(x + 4, y, chare);
        do_char(x + 5, y, charf);
    }

    fun do_char(x: int, y: int, char: StrConst) {
        var do_panic_check = true;
        if y >= size.y {
            // OOB
            y = size.y - 1;
            char = "-";
            do_panic_check = false; // This problem is already OOB (?)
        }

        var at = grid[y * size.x + x];
        if at[0] != "."[0] and do_panic_check {
            // print("panic @ ", (x, y), " ", at[0], " | ", char);
            // BUG: nil.or_panic() causes internal C error
            var x: Grid? = nil;
            x.or_panic();
        }
        grid[y * size.x + x] = char;
    }

    fun do_shape(x: int, y: int, shape: int) {
        shapes[shape](x, y, self);
    }
    
    fun do_shapes(x: int, y: int, count: int, shape: int) {
        var width = widths[shape];
        //print("use up ", count * width, " at ", x, " ", y);
        for i in 0..count {
            do_shape(x + i * width, y, shape);
        }
    }

    fun do_cc_shapes(x: int, y: int, count: int, ccs: Array[int]) {
        var idx = 0;
        var width = 3;
        for i in 0..count {
            while ccs[idx] <= 0 { idx = idx + 1; }
            do_shape(x + i * width, y, idx);
            ccs[idx] = ccs[idx] - 1;
        }
    }

    fun render_line(y: int) {
        var line = str("");
        for x in 0..size.x {
            line = str(line, grid[y * size.x + x]);
        }
        print(line);
    }

    fun render_me() {
        for y in 0..size.y {
            render_line(y);
        }
    }
}

fun make_grid(size: vec2i) -> Grid {
    var g = new Grid{};
    g.size = size;

    for i in 0..size.x {
        for j in 0..size.y {
            g.grid.push(".");
        }
    }

    g
}

class Problem {
    var size: vec2i = (0, 0);
    var counts: Array[int] = [0, 0, 0, 0, 0, 0];

    fun debug() {
        print(size.x, "x", size.y, " ", counts[0], " ", counts[1], " ",
            counts[2], " ", counts[3], " ", counts[4], " ", counts[5])
    }

    fun count_all_blocks(shapes: DynArray[Shape]) -> int {
        var sum = 0;
        for i in 0..shapes.length {
            sum = sum + shapes[i].count * counts[i];
        }
        sum
    }

    // fun second_debug() {
    //     var sum = 0.0;
    //     for i in 0..counts.length {
    //         sum = sum + counts[i];
    //     }
    //     var total_side_len = (sqrtit(sum));
    //     var x = roundit(total_side_len);
    //     var y = roundit(total_side_len) * 2 - x;
    //     print("sum = ", sum, " len = ", total_side_len, " ", size.x, " ", size.y, " | ", x * 3, " ", y * 3);
    // }

    fun debug_count(shapes: DynArray[Shape]) {
        var x = count_all_blocks(shapes);
        print("size: ", size, " => ", (size.x * size.y), " ", x, " ", (size.x * size.y) < x);
    }

    fun count_stuff(shapes: DynArray[Shape]) -> (bool, bool) {
        var c135s = 0;
        var c10s = 0;
        var c2s = 0;
        var cc: Array[int] = [0, 0, 0, 0, 0, 0];
        for i in 0..counts.length { cc[i] = counts[i]; }

        while cc[1] > 0 and cc[3] > 0 and cc[5] > 0 {
            c135s = c135s + 1;
            cc[1] = cc[1] - 1;
            cc[3] = cc[3] - 1;
            cc[5] = cc[5] - 1;
        }

        while cc[0] > 0 and cc[1] > 0 {
            c10s = c10s + 1;
            cc[1] = cc[1] - 1;
            cc[0] = cc[0] - 1;
        }

        while cc[2] > 1 {
            cc[2] = cc[2] - 2;
            c2s = c2s + 1;
        }

        //print("135-s: ", c135s, " 10-s: ", c10s, " 22-s: ", c2s);
        // Empty spaces is:
        // - 0 for each c135
        // - 1 for each 01
        // - 2 for each 22
        // - 2 for each 4
        // - 2 for each 0
        // 

        var grid = make_grid(size);

        var empty_spaces = 0;
        empty_spaces = empty_spaces + cc[0] * 2;
        empty_spaces = empty_spaces + cc[1] * 2;
        empty_spaces = empty_spaces + cc[2] * 2;
        empty_spaces = empty_spaces + cc[3] * 3;
        empty_spaces = empty_spaces + cc[4] * 2;
        empty_spaces = empty_spaces + cc[5] * 4;

        empty_spaces = empty_spaces + c135s * 0;
        empty_spaces = empty_spaces + c10s * 1;
        empty_spaces = empty_spaces + c2s * 1;

        var used_spaces = 0;
        for i in 0..shapes.length {
            used_spaces = used_spaces + counts[i] * shapes[i].count;
        }

        //print("empty spaces = ", empty_spaces, " used spaces = ", used_spaces, " sum = ", empty_spaces + used_spaces, " real = ", size.x * size.y);
        
        // early out..?
        if (empty_spaces + used_spaces) > (size.x * size.y) {
            return (false, false);
        }

        var other_3s = 0;
        for i in 0..6 {
            other_3s = other_3s + cc[i];
        }

        //print("-- size -- ", size);
        var space = size;
        while c135s > 0 {
            var rem = space.x;
            var width = 6;
            var avail = rem / width;
            if avail > c135s { avail = c135s; }
            grid.do_shapes(size.x - rem, size.y - space.y, avail, 6);
            rem = (rem - avail * width);
            //print("avail, width, rem = ", avail, " ", width, " ", rem);
            c135s = c135s - avail;
           

            if c10s > 0 {
                var width = 5;
                //if rem < width { break; };
                avail = rem / width;
                if avail > c10s { avail = c10s; }
                grid.do_shapes(size.x - rem, size.y - space.y, avail, 7);
                rem = (rem - avail * width);
                //print("rem => ", rem);
                c10s = c10s - avail;
                
            }

            if other_3s > 0 {
                var width = 3;
                //if rem < width { break; };
                avail = rem / width;
                //print("avail = ", avail);
                if avail > other_3s { avail = other_3s; }
                // TODO: every shape
                grid.do_cc_shapes(size.x - rem, size.y - space.y, avail, cc);
                rem = (rem - avail * width);
                //print("rem => ", rem);
                other_3s = other_3s - avail;

               
            }

            // for j in 0..6 {
            //     while cc[j] > 0 {
            //         var width = 3;
            //         if rem < width { break; };
            //         avail = rem / width;
            //         if avail > cc[j] { avail = cc[j]; }
            //         rem = (rem - avail * width);
            //         cc[j] = cc[j] - avail;
            //     }
            // }

            space.y = space.y - 3;
            //if avail <= 0 { break; }
        }

        while c10s > 0 {
            var rem = space.x;
            var width = 5;
            var avail = rem / width;
            if avail > c10s { avail = c10s; }
            //grid.render_me();
           // print("avail, width, rem = ", avail, " ", width, " ", rem);
            grid.do_shapes(size.x - rem, size.y - space.y, avail, 7);
            rem = (rem - avail * width);
            c10s = c10s - avail;
            

            if other_3s > 0 {
                var width = 5;
                //if rem < width { break; };
                avail = rem / width;
                if avail > other_3s { avail = other_3s; }
                // TODO: Every shape
                grid.do_cc_shapes(size.x - rem, size.y - space.y, avail, cc);
                rem = (rem - avail * width);
                other_3s = other_3s - avail;

                
            }

            space.y = space.y - 3;
            //if avail <= 0 { break; }
        }

        while other_3s > 0 {
            var rem = space.x;
            var width = 3;
            var avail = rem / width;
            if avail > other_3s { avail = other_3s; }
             // TODO: Shape
            grid.do_cc_shapes(size.x - rem, size.y - space.y, avail, cc);
            rem = (rem - avail * width);
            other_3s = other_3s - avail;
           

            // Here, we actually do want to allocate more c2s.
            var sizedelta = 3;
            if other_3s == 0 {
                var width = 4;
                if c2s > 0 {
                    var width = 4;
                    //if rem < width { break; };
                    avail = rem / width;
                    if avail > c2s { avail = c2s; }
                    if avail > 0 { sizedelta = 4; }
                   // print("avail, width, rem = ", avail, " ", width, " ", rem);
                    //grid.render_me();
                    grid.do_shapes(size.x - rem, size.y - space.y, avail, 8);
                    rem = (rem - avail * width);
                    c2s = c2s - avail;
                    
                }
            }

            space.y = space.y - sizedelta;
            //if avail <= 0 { break; }
        }

        while c2s > 0 {
            var rem = space.x;
            var width = 4;
            var avail = rem / width;
            if avail > c2s { avail = c2s; }
            //print("avail, width, rem = ", avail, " ", width, " ", rem);
            //grid.render_me();
            grid.do_shapes(size.x - rem, size.y - space.y, avail, 8);
            rem = (rem - avail * width);
            c2s = c2s - avail;

            space.y = space.y - 4;
            
           
            //if avail <= 0 { break; }
        }

        //print("leftover space.y: ", space.y);
        print("────────────────────────────────────────────────────────────");
        grid.render_me();
        print("────────────────────────────────────────────────────────────");
        return (space.y >= 0, true); // second tuple element is whether this one was 'interesting'
        
        //return (empty_spaces + used_spaces) <= (size.x * size.y);
    }
}

fun get_text() -> Text { new Text { text: read_file("input.txt") } }

fun init() {
    var text = get_text();

    var shapes: DynArray[Shape] = [];
    // Hard code 6 shapes. :)
    for i in 0..6 {
        shapes.push(text.shape());
    }

    var problems: DynArray[Problem] = [];
    loop {
        // BUG: need two semicolons after a break...
        problems.push(text.problem() else { break; });
    }

    var total = 0;

    for i in 0..problems.length {
        //problems[i].debug_count(shapes);
        
        var result = problems[i].count_stuff(shapes);
        if result.0 {
            total = total + 1;
        }
        print("problem #", i, " => ", result.0, " (interesting: ", result.1, ")");
        //problems[i].second_debug();
    }
    print("total = ", total);

    //print(problems.length);

    // for i in 0..shapes.length {
    //     shapes[i].debug();
    // }
    // for i in 0..problems.length {
    //     problems[i].debug();
    // }
}
