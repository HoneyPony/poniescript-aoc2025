var HASH = "#"[0];
var ZERO = "0"[0];
var NINE = "9"[0];

fun is_digit(c: int) -> bool {
    c >= ZERO and c <= NINE
}

fun is_not_digit(c: int) -> bool {
    c < ZERO or c > NINE
}

class Text {
    var text: StrBuf = "";
    var idx : int    = 0;

    var numbers: Array[int] = [0, 0, 0, 0, 0, 0, 0, 0];

    fun shape() -> Shape {
        idx = idx + 3;

        var s = new Shape {};
        var k = 0;

        for i in 0..3 {
            for j in 0..3 {
                s.array[k] = (text[idx] == HASH);
                if s.array[i] {
                    s.count = s.count + 1;
                }
                idx = idx + 1;
                k = k + 1;
            }
            idx = idx + 1; // skip newline
        }
        idx = idx + 1;

        s
    }

    fun problem() -> Problem? {
        if idx >= text.length {
            return nil;
        }

        for i in 0..numbers.length {
            while is_not_digit(text[idx]) {
                idx = idx + 1;       
            }

            var val = 0;
            while is_digit(text[idx]) {
                val = (val * 10 + text[idx] - ZERO);
                idx = idx + 1;
            }

            while idx < text.length and is_not_digit(text[idx]) {
                idx = idx + 1;       
            }

            numbers[i] = val;
        }

        var p = new Problem{};
        p.size = (numbers[0], numbers[1]);
        for i in 2..numbers.length {
            p.counts[i - 2] = numbers[i];
        }
        p
    }
}

class Shape {
    var array: Array[bool] = 
       [false, false, false,
        false, false, false,
        false, false, false];

    var count: int = 0;

    fun debug() {
        fun r(b: bool) -> StrConst { lerp(".", "#", b) }
        print(
            r(array[0]), r(array[1]), r(array[2]), "\n",
            r(array[3]), r(array[4]), r(array[5]), "\n",
            r(array[6]), r(array[7]), r(array[8])
        )
    }
}

class Grid {
    var size: vec2i = (0, 0);
    var grid: DynArray[bool] = [];
    
    fun install(rect: vec2i) {

    }
}

class Problem {
    var size: vec2i = (0, 0);
    var counts: Array[int] = [0, 0, 0, 0, 0, 0];

    fun debug() {
        print(size.x, "x", size.y, " ", counts[0], " ", counts[1], " ",
            counts[2], " ", counts[3], " ", counts[4], " ", counts[5])
    }

    fun count_all_blocks(shapes: DynArray[Shape]) -> int {
        var sum = 0;
        for i in 0..shapes.length {
            sum = sum + shapes[i].count * counts[i];
        }
        sum
    }

    fun second_debug() {
        var sum = 0.0;
        for i in 0..counts.length {
            sum = sum + counts[i];
        }
        var total_side_len = (sqrtit(sum));
        var x = roundit(total_side_len);
        var y = roundit(total_side_len) * 2 - x;
        print("sum = ", sum, " len = ", total_side_len, " ", size.x, " ", size.y, " | ", x * 3, " ", y * 3);
    }

    fun debug_count(shapes: DynArray[Shape]) {
        var x = count_all_blocks(shapes);
        print("size: ", size, " => ", (size.x * size.y), " ", x, " ", (size.x * size.y) < x);
    }

    fun count_stuff(shapes: DynArray[Shape]) -> bool {
        var c135s = 0;
        var c10s = 0;
        var c2s = 0;
        var cc: Array[int] = [0, 0, 0, 0, 0, 0];
        for i in 0..counts.length { cc[i] = counts[i]; }

        while cc[1] > 0 and cc[3] > 0 and cc[5] > 0 {
            c135s = c135s + 1;
            cc[1] = cc[1] - 1;
            cc[3] = cc[3] - 1;
            cc[5] = cc[5] - 1;
        }

        while cc[0] > 0 and cc[1] > 0 {
            c10s = c10s + 1;
            cc[1] = cc[1] - 1;
            cc[0] = cc[0] - 1;
        }

        while cc[2] > 1 {
            cc[2] = cc[2] - 2;
            c2s = c2s + 1;
        }

        print("135-s: ", c135s, " 10-s: ", c10s, " 22-s: ", c2s);
        // Empty spaces is:
        // - 0 for each c135
        // - 1 for each 01
        // - 2 for each 22
        // - 2 for each 4
        // - 2 for each 0
        // 

        var empty_spaces = 0;
        empty_spaces = empty_spaces + cc[0] * 2;
        empty_spaces = empty_spaces + cc[1] * 2;
        empty_spaces = empty_spaces + cc[2] * 2;
        empty_spaces = empty_spaces + cc[3] * 3;
        empty_spaces = empty_spaces + cc[4] * 2;
        empty_spaces = empty_spaces + cc[5] * 4;

        empty_spaces = empty_spaces + c135s * 0;
        empty_spaces = empty_spaces + c10s * 1;
        empty_spaces = empty_spaces + c2s * 1;

        var used_spaces = 0;
        for i in 0..shapes.length {
            used_spaces = used_spaces + counts[i] * shapes[i].count;
        }

        print("empty spaces = ", empty_spaces, " used spaces = ", used_spaces, " sum = ", empty_spaces + used_spaces, " real = ", size.x * size.y);
        
        // early out..?
        if (empty_spaces + used_spaces) > (size.x * size.y) {
            return false;
        }

        var other_3s = 0;
        for i in 0..6 {
            other_3s = other_3s + cc[i];
        }

        var space = size;
        while c135s > 0 {
            var rem = space.x;
            var width = 6;
            var avail = rem / width;
            if avail > c135s { avail = c135s; }
            rem = (rem - avail * width);
            c135s = c135s - avail;

            while c10s > 0 {
                var width = 5;
                if rem < width { break; };
                avail = rem / width;
                if avail > c10s { avail = c10s; }
                rem = (rem - avail * width);
                c10s = c10s - avail;
            }

            while other_3s > 0 {
                var width = 5;
                if rem < width { break; };
                avail = rem / width;
                if avail > other_3s { avail = other_3s; }
                rem = (rem - avail * width);
                other_3s = other_3s - avail;
            }

            // for j in 0..6 {
            //     while cc[j] > 0 {
            //         var width = 3;
            //         if rem < width { break; };
            //         avail = rem / width;
            //         if avail > cc[j] { avail = cc[j]; }
            //         rem = (rem - avail * width);
            //         cc[j] = cc[j] - avail;
            //     }
            // }

            space.y = space.y - 3;
            //if avail <= 0 { break; }
        }

        while c10s > 0 {
            var rem = space.x;
            var width = 5;
            var avail = rem / width;
            if avail > c10s { avail = c10s; }
            rem = (rem - avail * width);
            c10s = c10s - avail;

            while other_3s > 0 {
                var width = 5;
                if rem < width { break; };
                avail = rem / width;
                if avail > other_3s { avail = other_3s; }
                rem = (rem - avail * width);
                other_3s = other_3s - avail;
            }

            space.y = space.y - 3;
            //if avail <= 0 { break; }
        }

        while other_3s > 0 {
            var rem = space.x;
            var width = 3;
            var avail = rem / width;
            if avail > other_3s { avail = other_3s; }
            rem = (rem - avail * width);
            other_3s = other_3s - avail;

            // Here, we actually do want to allocate more c2s.
            var sizedelta = 3;
            if other_3s == 0 {
                var width = 4;
                sizedelta = 4;
                while c2s > 0 {
                    var width = 4;
                    if rem < width { break; };
                    avail = rem / width;
                    if avail > c2s { avail = c2s; }
                    rem = (rem - avail * width);
                    c2s = c2s - avail;
                }
            }

            space.y = space.y - 3;
            //if avail <= 0 { break; }
        }

        while c2s > 0 {
            var rem = space.x;
            var width = 4;
            var avail = rem / width;
            if avail > c2s { avail = c2s; }
            rem = (rem - avail * width);
            c2s = c2s - avail;

            space.y = space.y - 3;
            //if avail <= 0 { break; }
        }

        print("leftover space.y: ", space.y);
        return space.y >= 0;
        
        //return (empty_spaces + used_spaces) <= (size.x * size.y);
    }
}

fun get_text() -> Text { new Text { text: read_file("input.txt") } }

fun init() {
    var text = get_text();

    var shapes: DynArray[Shape] = [];
    // Hard code 6 shapes. :)
    for i in 0..6 {
        shapes.push(text.shape());
    }

    var problems: DynArray[Problem] = [];
    loop {
        // BUG: need two semicolons after a break...
        problems.push(text.problem() else { break; });
    }

    var total = 0;

    for i in 0..problems.length {
        //problems[i].debug_count(shapes);
        if problems[i].count_stuff(shapes) {
            total = total + 1;
        }
        //problems[i].second_debug();
    }
    print("total = ", total);

    //print(problems.length);

    // for i in 0..shapes.length {
    //     shapes[i].debug();
    // }
    // for i in 0..problems.length {
    //     problems[i].debug();
    // }
}
